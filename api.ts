/* tslint:disable */
/* eslint-disable */
/**
 * Slurpy
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    loc: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}

/**
 * EmailApi - axios parameter creator
 * @export
 */
export const EmailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get email
         * @summary Get Mail
         * @param {string} email 
         * @param {string} password 
         * @param {string} folder 
         * @param {number} timeout 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail: async (email: string, password: string, folder: string, timeout: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling getEmail.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling getEmail.');
            }
            // verify required parameter 'folder' is not null or undefined
            if (folder === null || folder === undefined) {
                throw new RequiredError('folder','Required parameter folder was null or undefined when calling getEmail.');
            }
            // verify required parameter 'timeout' is not null or undefined
            if (timeout === null || timeout === undefined) {
                throw new RequiredError('timeout','Required parameter timeout was null or undefined when calling getEmail.');
            }
            const localVarPath = `/api/v1.0/email/mail/{email}/{password}/{folder}/{timeout}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)))
                .replace(`{${"password"}}`, encodeURIComponent(String(password)))
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)))
                .replace(`{${"timeout"}}`, encodeURIComponent(String(timeout)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get inbox folders
         * @summary Get Folders
         * @param {string} email 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxFolders: async (email: string, password: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling getInboxFolders.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling getInboxFolders.');
            }
            const localVarPath = `/api/v1.0/email/folders/{email}/{password}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)))
                .replace(`{${"password"}}`, encodeURIComponent(String(password)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get unseen email
         * @summary Get Unseen
         * @param {string} email 
         * @param {string} password 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnseen: async (email: string, password: string, limit: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling getUnseen.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling getUnseen.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling getUnseen.');
            }
            const localVarPath = `/api/v1.0/email/unseen/{email}/{password}/{limit}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)))
                .replace(`{${"password"}}`, encodeURIComponent(String(password)))
                .replace(`{${"limit"}}`, encodeURIComponent(String(limit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailApi - functional programming interface
 * @export
 */
export const EmailApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get email
         * @summary Get Mail
         * @param {string} email 
         * @param {string} password 
         * @param {string} folder 
         * @param {number} timeout 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmail(email: string, password: string, folder: string, timeout: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await EmailApiAxiosParamCreator(configuration).getEmail(email, password, folder, timeout, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get inbox folders
         * @summary Get Folders
         * @param {string} email 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInboxFolders(email: string, password: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await EmailApiAxiosParamCreator(configuration).getInboxFolders(email, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get unseen email
         * @summary Get Unseen
         * @param {string} email 
         * @param {string} password 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnseen(email: string, password: string, limit: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await EmailApiAxiosParamCreator(configuration).getUnseen(email, password, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EmailApi - factory interface
 * @export
 */
export const EmailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get email
         * @summary Get Mail
         * @param {string} email 
         * @param {string} password 
         * @param {string} folder 
         * @param {number} timeout 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail(email: string, password: string, folder: string, timeout: number, options?: any): AxiosPromise<any> {
            return EmailApiFp(configuration).getEmail(email, password, folder, timeout, options).then((request) => request(axios, basePath));
        },
        /**
         * Get inbox folders
         * @summary Get Folders
         * @param {string} email 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxFolders(email: string, password: string, options?: any): AxiosPromise<any> {
            return EmailApiFp(configuration).getInboxFolders(email, password, options).then((request) => request(axios, basePath));
        },
        /**
         * Get unseen email
         * @summary Get Unseen
         * @param {string} email 
         * @param {string} password 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnseen(email: string, password: string, limit: number, options?: any): AxiosPromise<any> {
            return EmailApiFp(configuration).getUnseen(email, password, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmailApi - object-oriented interface
 * @export
 * @class EmailApi
 * @extends {BaseAPI}
 */
export class EmailApi extends BaseAPI {
    /**
     * Get email
     * @summary Get Mail
     * @param {string} email 
     * @param {string} password 
     * @param {string} folder 
     * @param {number} timeout 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    public getEmail(email: string, password: string, folder: string, timeout: number, options?: any) {
        return EmailApiFp(this.configuration).getEmail(email, password, folder, timeout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get inbox folders
     * @summary Get Folders
     * @param {string} email 
     * @param {string} password 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    public getInboxFolders(email: string, password: string, options?: any) {
        return EmailApiFp(this.configuration).getInboxFolders(email, password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get unseen email
     * @summary Get Unseen
     * @param {string} email 
     * @param {string} password 
     * @param {number} limit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    public getUnseen(email: string, password: string, limit: number, options?: any) {
        return EmailApiFp(this.configuration).getUnseen(email, password, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InboxApi - axios parameter creator
 * @export
 */
export const InboxApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create inbox with specified credentials
         * @summary Create Inbox
         * @param {string} email 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox: async (email: string, password: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling createInbox.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling createInbox.');
            }
            const localVarPath = `/api/v1.0/inbox/{email}/{password}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)))
                .replace(`{${"password"}}`, encodeURIComponent(String(password)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create inbox with random credentials
         * @summary Create Random Inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRandomInbox: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1.0/inbox/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of created inboxes
         * @summary Get Inboxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxesList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1.0/inbox/inboxes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InboxApi - functional programming interface
 * @export
 */
export const InboxApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create inbox with specified credentials
         * @summary Create Inbox
         * @param {string} email 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInbox(email: string, password: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await InboxApiAxiosParamCreator(configuration).createInbox(email, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create inbox with random credentials
         * @summary Create Random Inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRandomInbox(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await InboxApiAxiosParamCreator(configuration).createRandomInbox(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get list of created inboxes
         * @summary Get Inboxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInboxesList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await InboxApiAxiosParamCreator(configuration).getInboxesList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InboxApi - factory interface
 * @export
 */
export const InboxApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create inbox with specified credentials
         * @summary Create Inbox
         * @param {string} email 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox(email: string, password: string, options?: any): AxiosPromise<any> {
            return InboxApiFp(configuration).createInbox(email, password, options).then((request) => request(axios, basePath));
        },
        /**
         * Create inbox with random credentials
         * @summary Create Random Inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRandomInbox(options?: any): AxiosPromise<any> {
            return InboxApiFp(configuration).createRandomInbox(options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of created inboxes
         * @summary Get Inboxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxesList(options?: any): AxiosPromise<any> {
            return InboxApiFp(configuration).getInboxesList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InboxApi - object-oriented interface
 * @export
 * @class InboxApi
 * @extends {BaseAPI}
 */
export class InboxApi extends BaseAPI {
    /**
     * Create inbox with specified credentials
     * @summary Create Inbox
     * @param {string} email 
     * @param {string} password 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    public createInbox(email: string, password: string, options?: any) {
        return InboxApiFp(this.configuration).createInbox(email, password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create inbox with random credentials
     * @summary Create Random Inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    public createRandomInbox(options?: any) {
        return InboxApiFp(this.configuration).createRandomInbox(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of created inboxes
     * @summary Get Inboxes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    public getInboxesList(options?: any) {
        return InboxApiFp(this.configuration).getInboxesList(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobsApi - axios parameter creator
 * @export
 */
export const JobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get job status and result by its id
         * @summary Get Job Result
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobResult: async (jobId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling getJobResult.');
            }
            const localVarPath = `/api/v1.0/job/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get job status and result by its id
         * @summary Get Job Result
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobResult(jobId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await JobsApiAxiosParamCreator(configuration).getJobResult(jobId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get job status and result by its id
         * @summary Get Job Result
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobResult(jobId: string, options?: any): AxiosPromise<any> {
            return JobsApiFp(configuration).getJobResult(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * Get job status and result by its id
     * @summary Get Job Result
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobResult(jobId: string, options?: any) {
        return JobsApiFp(this.configuration).getJobResult(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}


